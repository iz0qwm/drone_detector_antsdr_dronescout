-----------------
DRONE DETECTOR
-----------------
-----------------
Drone ID e Remote ID
-----------------


192.168.1.10
AntSDR - Firmware Alphafox:
User: root
Password: abawavearm
-----------------------
192.168.1.5
Login: pi
Password: raspberry
-----------------------


systemctl status drone_services.service

sudo systemctl stop drone_services.service
sudo systemctl start drone_services.service

journalctl -u drone_services.service -f

-------------------------------------
VERSASYNC
-------------------------------------
Please read this page to understand how has been configured:
http://www.unixwiz.net/techtips/raspberry-pi3-gps-time.html

The important services are:
ntpd
gpsd

The GPIO 4 is used for the PPS and is set in the boot. Look at /boot/config.txt
It creates the /dev/pps0.
You can test with: ppstest /dev/pps0

To test the ntp: ntpq -p

# ntpq -p
remote refid st t when poll reach delay offset jitter
==============================================================================
+SHM(0) .GPS. 0 l 15 64 17 0.000 -65.198 14.456
*SHM(2) .PPS. 0 l 13 64 17 0.000 523.376 31.813

If you see the * it means that the ntp is working with a clock reference.

-------------------------------------
VERSASYNC
-------------------------------------




-----------------------
CRPC
-----------------------
192.168.1.6
login: raffaello
password: solita

IMMAGINI RF:
https://universe.roboflow.com/rui-shi/drone-signal-detect-few-shot/dataset/6/images



-----------------------------------------------------------------------------------
UTILIZZARE --break-system-packages   per installare con pip
-----------------------------------------------------------------------------------
python3 -m pip install --upgrade pip setuptools wheel --break-system-packages

-----------------------------
VENV solo per ADDESTRAMENTO
-----------------------------
python3 -m venv --system-site-packages ~/yolo-venv
source ~/yolo-venv/bin/activate

# Pin NumPy < 2 per compatibilità con i moduli apt
pip install --upgrade "numpy==1.26.4" pip

# Installa Ultralytics senza far aggiornare numpy
pip install --no-deps ultralytics
pip install "opencv-python<4.10" "pillow<11" "matplotlib<3.9"  # dipendenze base compatibili


-----------------------------------------------------------------
ADDESTRAMENTO
-----------------------------------------------------------------
# dentro al venv
source ~/yolo-venv/bin/activate
export PYTHONNOUSERSITE=1
export MPLBACKEND=Agg

python - <<'PY'
from ultralytics import YOLO
m = YOLO('yolov8n.pt')
# plots=False evita matplotlib (meno rogne con numpy/font)
m.train(
    data='/home/raffaello/dataset/yolo_vision/data.yaml',
    epochs=50, imgsz=640, batch=8, workers=2,
    project='/home/raffaello/yolo_runs', name='rf_yolo',
    plots=False
)
PY
-----------------------------------------------------------------
Dove trovare i pesi e i risultati
-----------------------------------
Cartella run: /home/raffaello/yolo_runs/rf_yolo3/

Pesi: weights/best.pt (il migliore) e weights/last.pt

Log/metrics: results.csv nella root della run

------------------------------------------
HACK-RF
------------------------------------------
mkfifo /tmp/hackrf_2400_2500.fifo
mkfifo /tmp/hackrf_5725_5875.fifo

SCRIPTS

File di configurazione:  /etc/default/crpc 
/etc/systemd/system/crpc.target
/etc/systemd/system/crpc-prepare.service
/etc/systemd/system/crpc-sweep.service
/etc/systemd/system/crpc-tiles.service
/etc/systemd/system/crpc-yolo.service
/etc/systemd/system/crpc-tracker.service
# /etc/systemd/system/crpc-assoc.service
/etc/systemd/system/crpc-rfscan.service
/etc/systemd/system/crpc-cleanup.service
/etc/systemd/system/rfe-dual-scan.service
/etc/systemd/system/rfe-csv-bridge.service
----------------------------------
# Stato generale
systemctl status crpc.target

# Servizi singoli
systemctl status crpc-sweep.service
journalctl -u crpc-sweep.service -f

systemctl status crpc-tiles.service
journalctl -u crpc-yolo.service -f   # qui vedi YOLO + detections

systemctl status crpc-tracker.service
journalctl -u crpc-rfscan.service -f

-----------------------------------
Modifica /etc/default/crpc (es. YOLO_CONF=0.05) e poi:

sudo systemctl restart crpc-yolo.service

------------------------------------
start_all/stop_all MANUALE

/usr/local/bin/start_crpc 
/usr/local/bin/stop_crpc
------------------------------------
PULIZIA FILES
/usr/local/bin/crpc_cleanup.sh

-------------------------------------
CONTROLLO
crpc_monitor

CLASSIFICATORE:
-------------------------------------------
BILANCIATO

python3 rf_scan_classifier.py \
  --w-model 0.45 --w-csv 0.35 --w-img 0.20 \
  --min-track-len 1 --fprint-min 0.05 \
  --dets-tail-kb 200 --dets-tail-lines 2000
-------------------------------------------
RUMOROSO:

python3 /mnt/data/rf_scan_classifier.py \
  --w-model 0.35 --w-csv 0.30 --w-img 0.35
-------------------------------------------
VIDEO FORTE:

python3 /mnt/data/rf_scan_classifier.py \
  --w-model 0.40 --w-csv 0.45 --w-img 0.15
-------------------------------------------
ALTA PRECISIONE:
python3 rf_scan_classifier.py \
  --fprint-min 0.20
  
  OPPURE
  
  --fprint-min 0.35
-------------------------------------------
YOLO "video" aiuta:
python3 rf_scan_classifier.py \
  --w-model 0.45 --w-csv 0.35 --w-img 0.20


------------------------------------------------
HACKRF MODALITA' WATERFALL
------------------------------------------------
mkfifo /tmp/hackrf.iq

# Centra dove vuoi guardare (es. 2.44 GHz), SR 10 Msps; regola guadagni se serve
hackrf_transfer -f 2440000000 -s 10000000 -a 1 -l 16 -g 32 -r /tmp/hackrf.iq

Utilizza in un'altra finestra:
python waterfall_web.py

------------------------------------------------
TILES
------------------------------------------------
Come usarlo (esempi veloci)

Waterfall top‑down stile RFUAV/Phantom4 (span 5 MHz, pannello 0.10 s, colori a picchi vividi):

python3 iq_to_tiles_cmap_arg.py \
  --freq-mode rel --fs-view 5000000 --duration 0.10 \
  --mode EWMA --alpha 0.2 \
  --db-floor -100 --db-ceil -50 --gamma 0.9 \
  --cmap orange_red


Peak‑hold:

python3 iq_to_tiles_cmap_arg.py \
  --freq-mode rel --fs-view 5000000 --duration 0.10 \
  --mode MAX --db-floor -100 --db-ceil -50 --gamma 0.9 --cmap turbo


Assi in MHz assoluti con overlay CF/BW (se scrivi la CF nei file /tmp/center_*.txt):

python3 iq_to_tiles_cmap_arg.py \
  --freq-mode abs --fs-view 5000000 --duration 0.10 \
  --mode EWMA --alpha 0.2 --db-floor -100 --db-ceil -50 --gamma 0.9


Nota: NON usare --detrend se vuoi mantenere il gradiente di fondo (arancio→verde) tipico delle immagini che stai guardando. Se invece vuoi un fondo piatto, aggiungi --detrend.


---------------------------
Comando consigliato


python3 iq_to_tiles_cmap_arg.py --fs 10e6 --fs-view 1.2e6 --nfft 65536 --hop-div 1 --mode EWMA --alpha 0.12 --norm bgsub --bg-alpha 0.015 --fast-settle-cols 120 --fast-settle-alpha 0.20 --delta-floor -6 --delta-ceil 10 --gamma 1.35 --cmap orange_red --dc-notch

iq_to_tiles_cmap_arg.py --fs 10e6 --fs-view 1.2e6 --nfft 65536 --hop-div 1 --mode EWMA --alpha 0.12 --norm bgsub --bg-alpha 0.015 --fast-settle-cols 120 --fast-settle-alpha 0.20 --delta-floor -8 --delta-ceil 10 --gamma 1.35 --cmap orange_red --dc-notch



Dritte di fino

Se l’immagine diventa “troppo scia”: abbassa alpha (es. 0.26 → 0.22).

Se il fondo “insegue” troppo lentamente: abbassa bg-alpha (0.06 → 0.04).

Se i mattoncini perdono contrasto: alza gamma (1.35) o porta --delta-floor a -8.

Se vuoi ancora più timeline (e la CPU regge), tieni hop-div 1 e 
aumenta la larghezza immagine se il tuo script ha un flag tipo 
--cols/--tile-width (es. 2048 → ~13.4 s). In mancanza del flag, il modo più semplice resta ridurre hop-div.
---------------------------------
PER DATASET APPRENDIMENTO

python3 /home/raffaello/crpc/iq_to_tiles_cmap_arg.py \
  --fs 10e6 --fs-view 1.2e6 \
  --nfft 65536 --hop-div 8 \
  --mode EWMA --alpha 0.20 \
  --norm bgsub --bg-alpha 0.02 \
  --fast-settle-cols 120 --fast-settle-alpha 0.25 \
  --delta-floor -10 --delta-ceil 10 \
  --gamma 1.3 \
  --cmap turbo \
  --dc-notch



-----------------------------------
APPRENDITORE
------------------------------------

ESEGUIRE PER INSERIRE I DATI APPRENDIMENTO NEL DATASET

Esempio (adatta i percorsi se servono):

python3 make_yolo_from_recordings.py \
  --base /home/raffaello/apprendimento/data/recordings \
  --out  /home/raffaello/dataset/yolo_custom \
  --split 0.85 \
  --prefer cum,best,live \
  --class-map /home/raffaello/apprendimento/class_map.json \
  --fs-view-mhz 1.2


Opzioni utili:

--class-map /path/map.json per mappare Air3S → "DJI AIR3S", ecc.

--kstd 2.0 cambia la soglia (mean + k*std) per trovare la banda.

--min-width-frac 0.01 impone una larghezza minima della banda (in frazione larghezza immagine).

---------------------------------------------
COLLEGAMENTO ANTENNE PER PSEUDO-DOPPLER
---------------------------------------------

PIN MAPPING

| Funzione               | Switch               | Segnale | GPIO (BCM) | Pin fisico | Note                                           |
| ---------------------- | -------------------- | ------- | ---------- | ---------- | ---------------------------------------------- |
| Antenna select bit 0   | **SP4T**             | S0      | **17**     | 11         | con pull-down                                  |
| Antenna select bit 1   | **SP4T**             | S1      | **27**     | 13         | con pull-down                                  |
| (opz) Enable           | **SP4T**             | EN      | **22**     | 15         | alto=abilitato; se il modulo non lo ha, ignora |
| RFE ↔ HackRF           | **SPDT #1 (HMC849)** | H       | **23**     | 16         | 0=RFE, 1=HackRF                                |
| Ingresso RFE 2.4 ↔ 5.x | **SPDT #2 (HMC849)** | B       | **24**     | 18         | 0=2.4, 1=5.x                                   |
| (opz) LED stato        | —                    | LED     | **25**     | 22         | comodo per debug                               |


Alimentazioni e masse:
------------------------
3V3 (pin 1/17) per la logica dei segnali.

5V (pin 2/4) se i moduli degli switch richiedono alimentazione 5 V (molti la accettano).

GND ben comune (pin 6/9/14/20/25/30/34/39).

Metti resistenze in serie 100–330 Ω sui fili di controllo e attiva i pull-down interni: eviti commutazioni spurie al boot.

Se uno dei moduli pretende logica 5 V in ingresso: usa un level shifter (anche un semplice NPN + pull-up a 5 V per linea va bene). Con HMC849 solitamente il “CTRL” accetta 3.3–5 V, quindi i GPIO a 3.3 V vanno bene.

Tabella verità
----------------
SP4T (2 bit) — 4 patch N/E/S/O

Se il tuo modulo ha ingressi S0/S1 “binary select” (tipico):

| S1 | S0 | Antenna      |
| -- | -- | ------------ |
| 0  | 0  | **N** (0°)   |
| 0  | 1  | **E** (90°)  |
| 1  | 0  | **S** (180°) |
| 1  | 1  | **O** (270°) |


Se invece il tuo SP4T ha 4 ingressi separati CH1..CH4 “one-hot”, usa quattro GPIO (es. 17,27,22,23) e porta alto solo la linea del canale scelto (le altre basse).

SPDT #1 — instradamento uscita verso RFE o HackRF

H=0 → RFE

H=1 → HackRF

SPDT #2 — scelta dell’ingresso RFE

B=0 → 2.4 GHz

B=1 → 5.x GHz (5.2/5.8 secondo cablaggio)

Schema a blocchi (posizioni PAD/BPF/LNA)
4× Patch (N/E/S/O) → SP4T → [PAD 6–10 dB] → [LNA 10–20 dB]
                                   │
                                 SPDT#1 (H): 0=RFE, 1=HackRF
                           ┌───────┴───────────┐
                           │                   └─→ [PAD 3–10 dB] → HackRF
                        SPDT#2 (B)
                   0=2.4         1=5.x
                   │                │
             [BPF 2.4] → RFE IN2.4  [BPF 5.8] → RFE IN5.x
